// Package handlers provides HTTP request handlers for the API Gateway.
// Generated by generate_api_gateway_routes.py
//
// Sentry/Bugsink Proxy Handler
// Proxies error tracking requests to the Bugsink service
//
// Associated Frontend Files:
//   - web/app/src/lib/error-tracking.ts (Sentry SDK initialization and error capture)
//   - web/app/src/lib/api.ts (error capture to Sentry on API failures)
//   - web/app/src/main.tsx (Sentry initialization on app start)
package handlers

import (
	"io"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/ugjb/api-gateway/config"
	"go.uber.org/zap"
)

// SentryProxyHandler handles proxying to Bugsink/Sentry
type SentryProxyHandler struct {
	config *config.Config
	logger *zap.Logger
}

// NewSentryProxyHandler creates a new SentryProxyHandler
func NewSentryProxyHandler(cfg *config.Config, logger *zap.Logger) *SentryProxyHandler {
	return &SentryProxyHandler{
		config: cfg,
		logger: logger,
	}
}

// ProxySentryStore handles /sentry/api/{project_id}/store/ endpoint
// This is the main endpoint for receiving error events
func (h *SentryProxyHandler) ProxySentryStore() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Validate Sentry authentication header
		authHeader := c.GetHeader("X-Sentry-Auth")
		if authHeader == "" {
			c.JSON(http.StatusForbidden, gin.H{
				"error": "Missing X-Sentry-Auth header",
			})
			return
		}

		// Parse sentry_key from auth header
		sentryKey := ""
		parts := strings.Split(authHeader, ",")
		for _, part := range parts {
			part = strings.TrimSpace(part)
			if strings.HasPrefix(part, "Sentry ") {
				part = strings.TrimPrefix(part, "Sentry ")
			}
			if strings.HasPrefix(part, "sentry_key=") {
				sentryKey = strings.TrimPrefix(part, "sentry_key=")
				break
			}
		}

		if sentryKey == "" {
			c.JSON(http.StatusBadRequest, gin.H{
				"error": "Invalid X-Sentry-Auth header: missing sentry_key",
			})
			return
		}

		h.proxyToBugsink(c)
	}
}

// ProxySentryEnvelope handles /sentry/api/{project_id}/envelope/ endpoint
func (h *SentryProxyHandler) ProxySentryEnvelope() gin.HandlerFunc {
	return func(c *gin.Context) {
		sentryKey := c.Query("sentry_key")
		if sentryKey == "" {
			authHeader := c.GetHeader("X-Sentry-Auth")
			if authHeader != "" {
				parts := strings.Split(authHeader, ",")
				for _, part := range parts {
					part = strings.TrimSpace(part)
					if strings.HasPrefix(part, "Sentry ") {
						part = strings.TrimPrefix(part, "Sentry ")
					}
					if strings.HasPrefix(part, "sentry_key=") {
						sentryKey = strings.TrimPrefix(part, "sentry_key=")
						break
					}
				}
			}
		}

		if sentryKey == "" {
			c.JSON(http.StatusForbidden, gin.H{
				"error": "Missing sentry_key",
			})
			return
		}

		h.proxyToBugsink(c)
	}
}

// ProxySentryDSN handles requests to get DSN configuration
func (h *SentryProxyHandler) ProxySentryDSN() gin.HandlerFunc {
	return func(c *gin.Context) {
		h.proxyToBugsink(c)
	}
}

// ProxySentryCatchAll handles all other /sentry/* requests
func (h *SentryProxyHandler) ProxySentryCatchAll() gin.HandlerFunc {
	return func(c *gin.Context) {
		h.proxyToBugsink(c)
	}
}

// proxyToBugsink proxies the request to the Bugsink service
func (h *SentryProxyHandler) proxyToBugsink(c *gin.Context) {
	bugsinkURL := h.config.ServiceURLs.Bugsink
	if bugsinkURL == "" {
		c.JSON(http.StatusServiceUnavailable, gin.H{
			"error": "Bugsink service not configured",
		})
		return
	}

	target, err := url.Parse(bugsinkURL)
	if err != nil {
		h.logger.Error("Failed to parse Bugsink URL", zap.Error(err))
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal server error",
		})
		return
	}

	proxy := httputil.NewSingleHostReverseProxy(target)

	originalDirector := proxy.Director
	proxy.Director = func(req *http.Request) {
		originalDirector(req)
		req.URL.Path = strings.TrimPrefix(c.Request.URL.Path, "/sentry")
		req.URL.RawQuery = c.Request.URL.RawQuery
		req.Host = target.Host

		for key, values := range c.Request.Header {
			if len(values) > 0 {
				req.Header.Set(key, values[0])
				for _, value := range values[1:] {
					req.Header.Add(key, value)
				}
			}
		}

		req.Header.Set("X-Forwarded-For", c.ClientIP())
		req.Header.Set("X-Forwarded-Proto", "http")
		req.Header.Set("X-Real-IP", c.ClientIP())
	}

	proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
		h.logger.Error("Bugsink proxy error",
			zap.Error(err),
			zap.String("target", bugsinkURL),
			zap.String("path", c.Request.URL.Path),
		)
		c.JSON(http.StatusBadGateway, gin.H{
			"error":   "Bugsink service unavailable",
			"details": err.Error(),
		})
	}

	if c.Request.Method == "POST" {
		body, _ := io.ReadAll(c.Request.Body)
		c.Request.Body = io.NopCloser(strings.NewReader(string(body)))
		h.logger.Debug("Proxying to Bugsink",
			zap.String("method", c.Request.Method),
			zap.String("path", c.Request.URL.Path),
			zap.Int("body_size", len(body)),
		)
	}

	proxy.ServeHTTP(c.Writer, c.Request)
}